[
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nrgetattr\n\n rgetattr (obj, attr, *args)\n\nRecursive getattr (for nested attributes).\n\nsource\n\n\nrsetattr\n\n rsetattr (obj, attr, val)\n\nRecursive setattr (for nested attributes).\n\nsource\n\n\ndefault_formats\n\n default_formats ()\n\nDefault output formats for some very common statistics.\n\ndefault_formats()\n\n{'params': '{:.2f}',\n 'tstats': '{:.2f}',\n 'pvalues': '{:.3f}',\n 'se': '{:.2f}',\n 'r2': '{:.3f}',\n 'nobs': '{:.0f}'}\n\n\n\nsource\n\n\nget_stars\n\n get_stars (pvalues:pandas.core.series.Series, stars:dict={0.1: '*', 0.05:\n            '**', 0.01: '***'})\n\nFor each pvalue, check the lowest key in stars for which the pvalue is smaller than that key, and return the corresponding nr of stars.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npvalues\nSeries\n\nThis is compared to key of stars param to determine how many stars should be added\n\n\nstars\ndict\n{0.1: ‘’, 0.05: ’’, 0.01: ’’}\nTodo: default values to the left are star symbols that are not rendered correctly in markdown\n\n\nReturns\nSeries\n\n\n\n\n\n\nget_stars(pvalues= pd.Series([0.5, .03, 0.002], index=['x1','x2','x3']))\n\nx1       \nx2     **\nx3    ***\ndtype: object\n\n\n\nget_stars(pvalues= pd.Series([0.5, .03, 0.002], index=['x1','x2','x3']), \n          stars={0.4: '**', 0.9: '***'})\n\nx1    ***\nx2     **\nx3     **\ndtype: object\n\n\n\nsource\n\n\nmodel_groups\n\n model_groups (column_group_names:Dict[str,List[int]],\n               add_clines:bool=True)\n\nReturns LaTex code needed to add at the top of the table in order to give names to groups of columns in the table.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncolumn_group_names\nDict\n\nKeys are group titles, values are lists of column indices included in each group\n\n\nadd_clines\nbool\nTrue\nIf True, adds lines below group names\n\n\nReturns\nstr\n\n\n\n\n\n\nprint(model_groups(column_group_names={'Group 1':[0,1], 'Group 2':[2,3]}))\n\n& \\multicolumn{2}{c}{Group 1} & \\multicolumn{2}{c}{Group 2}  \\\\ \n\\cline{1-2} \\cline{3-4}  \n\n\n\n\nsource\n\n\ntex_table_env\n\n tex_table_env (nr_columns:int,\n                env:Literal['tabularx','tabular*']='tabular*')\n\nCreates LaTex code to add at the top of the table to create the correct tabular environment.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnr_columns\nint\n\nNumber of columns in the table\n\n\nenv\nLiteral\ntabular*\nLatex tabular environment specification\n\n\nReturns\nTuple\n\n\n\n\n\n\nheader,footer = tex_table_env(nr_columns=4, env='tabularx')\nprint(header)\nprint(footer)\n\n\\begin{tabularx}{\\textwidth}{@{}l *{4}{&gt;{\\centering\\arraybackslash}X}@{}}\n\\end{tabularx}\n\n\n\nheader,footer = tex_table_env(nr_columns=4, env='tabular*')\nprint(header)\nprint(footer)\n\n\\begin{tabular*}{\\textwidth}{@{\\extracolsep{\\fill}}l*{4}{c}}\n\\end{tabular*}\n\n\n\nsource\n\n\ndf_to_tex\n\n df_to_tex (df:pandas.core.frame.DataFrame, panel_title:str='',\n            palign:Literal['l','r','c']='l',\n            col_groups:Dict[str,List[int]]=None,\n            col_names:Union[List[str],bool]=True, hlines:List[int]=[],\n            tabular_env:str='tabular*')\n\nCreates LaTeX-formatted table from DataFrame.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\nDataFrame\n\nIf this has a MultiIndex, only the first level is kept\n\n\npanel_title\nstr\n\n\n\n\npalign\nLiteral\nl\nAlignment of panel title\n\n\ncol_groups\nDict\nNone\nKeys are group names; values are lists of consecutive indices of columns in the group\n\n\ncol_names\nUnion\nTrue\nIf False, none; if True, use df column names; if list, gives custom column names\n\n\nhlines\nList\n[]\nRow indices under which to place hline (use 0 for topline). adds under each line\n\n\ntabular_env\nstr\ntabular*\nLaTex tabular environment\n\n\nReturns\nstr\n\n\n\n\n\nPanel title (if any) will appear first, then column group names(if any), then column names (if any), then the body of the table.\n\ndf = pd.DataFrame(np.random.rand(5,4), index=['Var1','','Var2','','R2'], columns=list('ABCD'))\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nVar1\n0.153388\n0.740063\n0.318769\n0.741419\n\n\n\n0.981220\n0.349820\n0.750357\n0.868395\n\n\nVar2\n0.987855\n0.133089\n0.928428\n0.600271\n\n\n\n0.120149\n0.177721\n0.108870\n0.844516\n\n\nR2\n0.696665\n0.187199\n0.966317\n0.972379\n\n\n\n\n\n\n\n\ntex_string = df_to_tex(df, panel_title='Dependent variable is Y',\n                        col_groups={'Group 1':[1,2], 'Group 2': [3,4]},\n                        hlines=[0,2,7])\nprint(tex_string)\n\n\\begin{tabular*}{\\textwidth}{@{\\extracolsep{\\fill}}l*{4}{c}} \n \\hline \\noalign{\\smallskip} \n\\multicolumn{5}{@{} l}{Dependent variable is Y} \\\\ \n& \\multicolumn{2}{c}{Group 1} & \\multicolumn{2}{c}{Group 2}  \\\\ \n \\hline \\noalign{\\smallskip} \n\\cline{2-3} \\cline{4-5}  \n & A & B & C & D \\\\ \nVar1 & 0.15338774256333254 & 0.7400625640619886 & 0.31876894791132926 & 0.741418501204769 \\\\ \n & 0.981219771218718 & 0.34981974576456365 & 0.7503573114766038 & 0.8683948957807631 \\\\ \nVar2 & 0.9878546825283399 & 0.1330892261743063 & 0.9284283603986899 & 0.6002709049430831 \\\\ \n \\hline \\noalign{\\smallskip} \n & 0.12014853367450873 & 0.17772097286209887 & 0.10887029741896503 & 0.8445164146587155 \\\\ \nR2 & 0.6966651718648458 & 0.18719853238388184 & 0.9663168811371031 & 0.9723793915445124 \\\\ \n\\end{tabular*}\n\n\n\nsource\n\n\nmake_pdf_from_tex\n\n make_pdf_from_tex (tex_file_path:pathlib.Path|str)\n\nOutput PDF is created in the same folder as source tex file. Requires TexLive and its pdflatex utility\n\nsource\n\n\nopen_pdf_file\n\n open_pdf_file (file_path)",
    "crumbs": [
      "utils"
    ]
  },
  {
    "objectID": "linearmodels_results.html",
    "href": "linearmodels_results.html",
    "title": "linearmodels_results",
    "section": "",
    "text": "Each function extracts a particular statistic from the results object.\nThese functions must be consistent across the different statistical packages supported by estout.\nFor example, if we write functions to extract the F-statistic from the linearmodels and statsmodels packages, these functions must have the same name in the linearmodels_results and statsmodels_results modules. They must also have the same return type.\nThe names of these functions will be the keys of the dictionary returned by the collect_stats function in the core module.\n\n\nExported source\nimport numpy as np\nimport pandas as pd\n\n\n\nfrom linearmodels import PanelOLS\n\nSet up an example dataset and run a few regressions to showcase the functions in this module.\n\nnp.random.seed(123)\ndf = pd.DataFrame(np.random.rand(9,3), \n                  columns=['y','x','z'],\n                  index = pd.MultiIndex.from_product([[1,2,3],[1,2,3]], names=['firmid','time'])\n                  ).assign(cons = 1)\nlmres = PanelOLS(df['y'],  df[['cons','x','z']], entity_effects=True\n                 ).fit(cov_type='clustered', cluster_entity=True)\n\n\nsource\n\nynames\n\n ynames (res)\n\n\nynames(lmres)\n\n['y']\n\n\n\nsource\n\n\nxnames\n\n xnames (res)\n\n\nxnames(lmres)\n\n['cons', 'x', 'z']\n\n\n\nsource\n\n\nparams\n\n params (res)\n\n\nparams(lmres)\n\ncons    0.728016\nx       0.643274\nz      -0.774956\nName: parameter, dtype: float64\n\n\n\ntype(params(lmres))\n\npandas.core.series.Series\n\n\n\nsource\n\n\ntstats\n\n tstats (res)\n\n\ntstats(lmres)\n\ncons    167.358372\nx         2.262089\nz        -2.909770\nName: tstat, dtype: float64\n\n\n\nsource\n\n\npvalues\n\n pvalues (res)\n\n\npvalues(lmres)\n\ncons    7.646419e-09\nx       8.648041e-02\nz       4.368821e-02\nName: pvalue, dtype: float64\n\n\n\nsource\n\n\ncovmat\n\n covmat (res)\n\n\ncovmat(lmres)\n\n\n\n\n\n\n\n\ncons\nx\nz\n\n\n\n\ncons\n0.000019\n-0.000652\n0.000580\n\n\nx\n-0.000652\n0.080867\n-0.075700\n\n\nz\n0.000580\n-0.075700\n0.070931\n\n\n\n\n\n\n\n\nsource\n\n\nse\n\n se (res)\n\n\nse(lmres)\n\ncons    0.004350\nx       0.284371\nz       0.266329\nName: std_error, dtype: float64\n\n\n\nsource\n\n\nnobs\n\n nobs (res)\n\n\nnobs(lmres)\n\n9\n\n\n\nsource\n\n\nr2\n\n r2 (res)\n\n\nr2(lmres)\n\n0.35189790336774396",
    "crumbs": [
      "linearmodels_results"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "Short descriptions for main functions (see below for more details):\n\ncollect_stats: extracts a given set of attributes from results object generated by stats packages\nto_df: takes a list of collect_stats outputs and merges them as separate columns in a pandas DataFrame\nto_tex: takes one or more DataFrames and creates tex code to build table with each DataFrame as a different panel\nto_pdf: takes one or more tex tables (either as strings or paths to tex files) and merges them in a pdf document\n\n\n\nExported source\nfrom __future__ import annotations\nfrom pathlib import Path \nfrom typing import List, Dict, Literal, Union, Callable\nimport importlib\n\nimport numpy as np\nimport pandas as pd\nimport statsmodels.api as sm\nfrom linearmodels import PanelOLS\n\nfrom estout import utils\n\n\nSet up an example dataset and run a few regressions to showcase the functions in this module.\n\nnp.random.seed(123)\ndf = pd.DataFrame(np.random.rand(9,3), \n                  columns=['y','x','z'],\n                  index = pd.MultiIndex.from_product([[1,2,3],[1,2,3]], names=['firmid','time'])\n                  ).assign(cons = 1)\nsm1 = sm.OLS(df['y'], df[['cons','x']]).fit()\nsm2 = sm.OLS(df['y'], df[['cons','x','z']]).fit().get_robustcov_results(cov_type='HAC', maxlags=2)\nlmres = PanelOLS(df['y'],  df[['cons','x','z']], entity_effects=True\n                 ).fit(cov_type='clustered', cluster_entity=True)\n\n\nsource\n\ncollect_stats\n\n collect_stats (res, get_default_stats=True, add_stats:dict=None,\n                add_literals:dict=None)\n\nCollects stats from res object. Stats in add_stats can override default stats\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nres\n\n\nResults object to extract stats from\n\n\nget_default_stats\nbool\nTrue\nIf True, returns all stats implemented by the f'{package}_results' module\n\n\nadd_stats\ndict\nNone\nKeys are stats to extract in addition to the default ones; values are attributes of res or callables\n\n\nadd_literals\ndict\nNone\nAdditional info to be added to output dict; values must be scalars\n\n\nReturns\ndict\n\n\n\n\n\n\nstats1 = collect_stats(sm1)\nstats2 = collect_stats(sm2, add_literals={'Cov Type': 'Newey West'})\nstats3 = collect_stats(lmres, add_stats={'r2b': 'rsquared_between', 'FE':'included_effects'})\nstats4 = collect_stats(sm2, add_stats={'Max Eigen': lambda x: x.eigenvals.max()})\n\n\nstats1\n\n{'package': 'statsmodels',\n 'ynames': ['y'],\n 'xnames': ['cons', 'x'],\n 'params': cons    0.507852\n x       0.345003\n dtype: float64,\n 'tstats': cons    3.905440\n x       1.292246\n dtype: float64,\n 'pvalues': cons    0.005858\n x       0.237293\n dtype: float64,\n 'covmat':           cons         x\n cons  0.016910 -0.030531\n x    -0.030531  0.071278,\n 'se': cons    0.130037\n x       0.266979\n dtype: float64,\n 'nobs': 9,\n 'r2': np.float64(0.19260886185799475)}\n\n\n\nassert stats2['Cov Type'] == 'Newey West'\n\n\nstats3['r2b']\n\n0.7954933715233719\n\n\n\nstats3['FE']\n\n['Entity']\n\n\n\nsource\n\n\nto_df\n\n to_df (res_list:List[dict], which_xvars:list=None,\n        stats_body:list=['params', 'tstats'], stats_bottom:list=['r2',\n        'nobs'], labels:dict=None, add_formats:dict=None)\n\nCombines results from multiple collect_stats() outputs into a single pd.DataFrame\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nres_list\nList\n\nList of outputs from collect_stats()\n\n\nwhich_xvars\nlist\nNone\nIf None, report all xvars\n\n\nstats_body\nlist\n[‘params’, ‘tstats’]\nEach element of res_list needs to have these stats as keys; values must be pd.Series\n\n\nstats_bottom\nlist\n[‘r2’, ‘nobs’]\nEach element of res_list needs to have these stats as keys; values must be scalars\n\n\nlabels\ndict\nNone\n\n\n\nadd_formats\ndict\nNone\n\n\n\nReturns\nDataFrame\n\n\n\n\n\n\nd = to_df(res_list=[stats1, stats2, stats1, stats3], \n          which_xvars=['cons','x','z'], \n          add_formats={'r2':'{:.2f}'},\n          labels={'nobs':'Observations', 'r2':'$R^2$'})\nd\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\ncons\nparams\n0.51***\n0.70***\n0.51***\n0.73***\n\n\n\ntstats\n(3.91)\n(21.48)\n(3.91)\n(167.36)\n\n\nx\nparams\n0.35\n0.57**\n0.35\n0.64*\n\n\n\ntstats\n(1.29)\n(2.85)\n(1.29)\n(2.26)\n\n\nz\nparams\n\n-0.64**\n\n-0.77**\n\n\n\ntstats\n\n(-3.55)\n\n(-2.91)\n\n\n$R^2$\n\n0.19\n0.49\n0.19\n0.35\n\n\nObservations\n\n9\n9\n9\n9\n\n\n\n\n\n\n\nNote how we used a LaTex-friendly label for the \\(R^2\\) coefficient so we don’t have to re-label this row before we send it to LaTex.\n\nsource\n\n\nto_tex\n\n to_tex (dfs:Union[pandas.core.frame.DataFrame,List[pandas.core.frame.Data\n         Frame]], outfile:pathlib.Path|str=None, title:str='Table title',\n         notes:str='Table description', notes_on_top:bool=True,\n         label:str='',\n         table_type:Literal['table','sidewaystable']='table',\n         font_size:str='\\\\footnotesize', addtocounter:int=0,\n         panel_title:List[str]=None, palign:Literal['l','r','c']='l',\n         col_groups:List[dict]=None,\n         col_names:List[Union[list,bool]]=True,\n         hlines:List[List[int]]=None, tabular_env:str='tabular*')\n\nCreate tex code to generate table from one or more dataframes\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndfs\nUnion\n\nDataFrame(s) to be converted to tex table; if multiple, they will be panels in a larger table\n\n\noutfile\npathlib.Path | str\nNone\nWhere to save resulting tex output\n\n\ntitle\nstr\nTable title\nTable title\n\n\nnotes\nstr\nTable description\nSome call this the table caption\n\n\nnotes_on_top\nbool\nTrue\nSet to False if you want table description (caption) to be at the bottom\n\n\nlabel\nstr\n\nTable label (for referencing within LaTex document)\n\n\ntable_type\nLiteral\ntable\n\n\n\nfont_size\nstr\n\nGets applied to the table contents as well as its caption\n\n\naddtocounter\nint\n0\nSet to -1 for tables that are just a continuation of a table on a new page\n\n\npanel_title\nList\nNone\nOne element in the list for each dataframe in dfs\n\n\npalign\nLiteral\nl\nAlignment of panel title\n\n\ncol_groups\nList\nNone\nKeys are group names; values are lists of consecutive indices of columns in the group\n\n\ncol_names\nList\nTrue\nIf False, none; if True, use df column names; if list, gives custom column names\n\n\nhlines\nList\nNone\nRow indices under which to place hline\n\n\ntabular_env\nstr\ntabular*\nLaTex tabular environment\n\n\nReturns\nstr\n\n\n\n\n\n\ntbl = to_tex([d,d], panel_title=['Panel A: Some title', 'Panel B: Some title'], \n               col_groups=[{'Group1':[1,2]}]*2,\n               col_names=[['Model 1', 'Model 2', 'Model 3', 'Model 4']]*2,\n               hlines=[[0,1,4,12], [1,4,12]] )\n\n\nsource\n\n\nto_pdf\n\n to_pdf (outfile:str, table_tex_code:Union[str,pathlib.Path,List[Union[str\n         ,pathlib.Path]]]=None,\n         article_spec='\\\\documentclass[11pt]{article}',\n         captionsetup='format=plain, labelsep=newline, labelfont = bf,\n         justification=centering', make_pdf:bool=True,\n         open_pdf:bool=False)\n\nCreates PDF with one or more tables given their tex code (from to \\end{table})\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\noutfile\nstr\n\nPath to .tex file where combined tables are saved (must contain .tex extension)\n\n\ntable_tex_code\nUnion\nNone\nString(s) or Paths to files containing table tex code (e.g. like outputs of to_tex())\n\n\narticle_spec\nstr\n\n\n\n\ncaptionsetup\nstr\nformat=plain, labelsep=newline, labelfont = bf, justification=centering\n\n\n\nmake_pdf\nbool\nTrue\n\n\n\nopen_pdf\nbool\nFalse\n\n\n\n\nFor the test below to work, you need to have TexLive installed (and change the path below to a valid path on your system).\n\nto_pdf('../_outputs/paper.tex', table_tex_code=[tbl, tbl])\n\nPDF creation successful!",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "statsmodels_results.html",
    "href": "statsmodels_results.html",
    "title": "statsmodels_results",
    "section": "",
    "text": "Each function extracts a particular statistic from the results object.\nThese functions must be consistent across the different statistical packages supported by estout.\nFor example, if we write functions to extract the F-statistic from the linearmodels and statsmodels packages, these functions must have the same name in the linearmodels_results and statsmodels_results modules. They must also have the same return type.\nThe names of these functions will be the keys of the dictionary returned by the collect_stats function in the core module.\n\n\nExported source\nimport numpy as np\nimport pandas as pd\n\n\n\nimport statsmodels.api as sm\n\nSet up an example dataset and run a few regressions to showcase the functions in this module.\n\nnp.random.seed(123)\ndf = pd.DataFrame(np.random.rand(9,3), \n                  columns=['y','x','z'],\n                  index = pd.MultiIndex.from_product([[1,2,3],[1,2,3]], names=['firmid','time'])\n                  ).assign(cons = 1)\nsm1 = sm.OLS(df['y'], df[['cons','x']]).fit()\nsm2 = sm.OLS(df['y'], df[['cons','x','z']]).fit().get_robustcov_results(cov_type='HAC', maxlags=2)\n\nThe following functions will extract some key information from the sm1 and sm2 objects.\nNote that for results produced by .get_robustcov_results() (the sm2 example), many atributes (e.g. params, tstats, and pvalues) are returned as ndarray not pd.Series.\nSo we will convert them to pd.Series in the appropriate functions.\nThese statistics have to have the same name across all ’{package_name}_results’ modules.\n\nsource\n\nynames\n\n ynames (res)\n\n\nynames(sm1)\n\n['y']\n\n\n\nsource\n\n\nxnames\n\n xnames (res)\n\n\nxnames(sm1)\n\n['cons', 'x']\n\n\n\nsource\n\n\nparams\n\n params (res)\n\n\nparams(sm1)\n\ncons    0.507852\nx       0.345003\ndtype: float64\n\n\n\nparams(sm2)\n\ncons    0.698578\nx       0.571069\nz      -0.640497\ndtype: float64\n\n\n\nsource\n\n\ntstats\n\n tstats (res)\n\n\ntstats(sm1)\n\ncons    3.905440\nx       1.292246\ndtype: float64\n\n\n\ntstats(sm2)\n\ncons    21.482641\nx        2.848571\nz       -3.547016\ndtype: float64\n\n\n\nsource\n\n\npvalues\n\n pvalues (res)\n\n\npvalues(sm1)\n\ncons    0.005858\nx       0.237293\ndtype: float64\n\n\n\npvalues(sm2)\n\ncons    6.638188e-07\nx       2.923636e-02\nz       1.211566e-02\ndtype: float64\n\n\n\nsource\n\n\ncovmat\n\n covmat (res)\n\n\ncovmat(sm1)\n\n\n\n\n\n\n\n\ncons\nx\n\n\n\n\ncons\n0.016910\n-0.030531\n\n\nx\n-0.030531\n0.071278\n\n\n\n\n\n\n\n\ncovmat(sm2)\n\n\n\n\n\n\n\n\ncons\nx\nz\n\n\n\n\ncons\n0.001057\n0.002529\n-0.004205\n\n\nx\n0.002529\n0.040190\n-0.032507\n\n\nz\n-0.004205\n-0.032507\n0.032607\n\n\n\n\n\n\n\n\nsource\n\n\nse\n\n se (res)\n\n\nse(sm1)\n\ncons    0.130037\nx       0.266979\ndtype: float64\n\n\n\nse(sm2)\n\ncons    0.032518\nx       0.200476\nz       0.180574\ndtype: float64\n\n\n\nsource\n\n\nnobs\n\n nobs (res)\n\n\nnobs(sm1)\n\n9\n\n\n\nsource\n\n\nr2\n\n r2 (res)\n\n\nr2(sm1)\n\n0.19260886185799486",
    "crumbs": [
      "statsmodels_results"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "estout",
    "section": "",
    "text": "The full documentation site is here.\nHere is a short description for each main functions (see below for more details):",
    "crumbs": [
      "estout"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "estout",
    "section": "Install",
    "text": "Install\npip install estout",
    "crumbs": [
      "estout"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "estout",
    "section": "How to use",
    "text": "How to use\nFirst, we set up an example dataset and run a few regressions to showcase the functions in this module.\n\nimport numpy as np\nimport pandas as pd\nimport statsmodels.api as sm\nfrom linearmodels import PanelOLS\nimport estout\n\n\nnp.random.seed(123)\ndf = pd.DataFrame(np.random.rand(9,3), \n                  columns=['y','x','z'],\n                  index = pd.MultiIndex.from_product([[1,2,3],[1,2,3]], names=['firmid','time'])\n                  ).assign(cons = 1)\nsm1 = sm.OLS(df['y'], df[['cons','x']]).fit()\nsm2 = sm.OLS(df['y'], df[['cons','x','z']]).fit().get_robustcov_results(cov_type='HAC', maxlags=2)\nlmres = PanelOLS(df['y'],  df[['cons','x','z']], entity_effects=True\n                 ).fit(cov_type='clustered', cluster_entity=True)\n\n\nExtracting statistics after fitting a model\nBelow, we collect just the default set of statistics from the sm1 object.\n\nestout.collect_stats(sm1)\n\n{'package': 'statsmodels',\n 'ynames': ['y'],\n 'xnames': ['cons', 'x'],\n 'params': cons    0.507852\n x       0.345003\n dtype: float64,\n 'tstats': cons    3.905440\n x       1.292246\n dtype: float64,\n 'pvalues': cons    0.005858\n x       0.237293\n dtype: float64,\n 'covmat':           cons         x\n cons  0.016910 -0.030531\n x    -0.030531  0.071278,\n 'se': cons    0.130037\n x       0.266979\n dtype: float64,\n 'nobs': 9,\n 'r2': 0.19260886185799486}\n\n\nThis list of default statistics is given by the functions implemented in the statsmodels_results module (since sm1 was generated by the statsmodels package).\nThe same functions exist in the linearmodels_results module.\n\nprint(estout.statsmodels_results.__all__)\nprint(estout.linearmodels_results.__all__)\n\n['ynames', 'xnames', 'params', 'tstats', 'pvalues', 'covmat', 'se', 'nobs', 'r2']\n['ynames', 'xnames', 'params', 'tstats', 'pvalues', 'covmat', 'se', 'nobs', 'r2']\n\n\nI might add to (but never subtract from) this list in future versions if I find that there are other statistics I use very often.\nIf there are other statistics that you need, and they are reported as attributes in the results object, you can request them using the add_stats parameter:\n\nestout.collect_stats(sm1, get_default_stats=False, add_stats={'xnames': 'model.exog_names',\n                                                              'Adj. R2': 'rsquared_adj'})\n\n{'package': 'statsmodels',\n 'xnames': ['cons', 'x'],\n 'Adj. R2': 0.07726727069485129}\n\n\nThe add_stats parameter also takes custom functions for statistics that are not reported as an individual attribute of the results object. These custom functions must return scalars.\n\ndef allvars(lmres): return lmres.model.dependent.vars + lmres.model.exog.vars\nestout.collect_stats(lmres, get_default_stats=False, add_stats={'all': allvars})\n\n{'package': 'linearmodels', 'all': ['y', 'cons', 'x', 'z']}\n\n\nAdd scalar statistics not available as attributes of the results object (using the add_literals paramter):\n\nestout.collect_stats(sm1, get_default_stats=False, add_literals={'Fixed Effects': 'No', \n                                                                 'Nr observations': 123})\n\n{'package': 'statsmodels', 'Fixed Effects': 'No', 'Nr observations': 123}\n\n\n\n\nCombining model results into a DataFrame\nStart by collecting stats from each model and combining them in a list.\n\nallmodels = []\nfor res in [sm1, sm2, lmres]:\n    allmodels.append(estout.collect_stats(res))\n\nThen export them to a DataFrame.\n\nestout.to_df(allmodels)\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\ncons\nparams\n0.51***\n0.70***\n0.73***\n\n\n\ntstats\n(3.91)\n(21.48)\n(167.36)\n\n\nx\nparams\n0.35\n0.57**\n0.64*\n\n\n\ntstats\n(1.29)\n(2.85)\n(2.26)\n\n\nz\nparams\n\n-0.64**\n-0.77**\n\n\n\ntstats\n\n(-3.55)\n(-2.91)\n\n\nr2\n\n0.193\n0.487\n0.352\n\n\nnobs\n\n9\n9\n9\n\n\n\n\n\n\n\nWe can choose to report only a subset of the regressors.\n\nestout.to_df(allmodels, which_xvars=['x','z'])\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\nx\nparams\n0.35\n0.57**\n0.64*\n\n\n\ntstats\n(1.29)\n(2.85)\n(2.26)\n\n\nz\nparams\n\n-0.64**\n-0.77**\n\n\n\ntstats\n\n(-3.55)\n(-2.91)\n\n\nr2\n\n0.193\n0.487\n0.352\n\n\nnobs\n\n9\n9\n9\n\n\n\n\n\n\n\nReport other statistics under the parameter values.\n\nestout.to_df(allmodels, stats_body=['params','se','pvalues'], which_xvars=['x'])\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\nx\nparams\n0.35\n0.57**\n0.64*\n\n\n\nse\n(0.27)\n(0.20)\n(0.28)\n\n\npvalues\n(0.237)\n(0.029)\n(0.086)\n\n\nr2\n\n0.193\n0.487\n0.352\n\n\nnobs\n\n9\n9\n9\n\n\n\n\n\n\n\nChange the statistics reported at the bottom of the table\n\nestout.to_df(allmodels, stats_bottom=['r2'],  which_xvars=['x'])\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\nx\nparams\n0.35\n0.57**\n0.64*\n\n\n\ntstats\n(1.29)\n(2.85)\n(2.26)\n\n\nr2\n\n0.193\n0.487\n0.352\n\n\n\n\n\n\n\nChange the formatting for any of the statistics reported.\n\nestout.to_df(allmodels, add_formats={'params':'{:.3}','r2':'{:.2f}'}, which_xvars=['x'])\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\nx\nparams\n0.345\n0.571**\n0.643*\n\n\n\ntstats\n(1.29)\n(2.85)\n(2.26)\n\n\nr2\n\n0.19\n0.49\n0.35\n\n\nnobs\n\n9\n9\n9\n\n\n\n\n\n\n\nReplace names of regressor (or bottom stats) with labels.\n\nestout.to_df(allmodels, labels={'cons':'Intercept', 'nobs':'Observations'}, which_xvars=['cons'])\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\nIntercept\nparams\n0.51***\n0.70***\n0.73***\n\n\n\ntstats\n(3.91)\n(21.48)\n(167.36)\n\n\nr2\n\n0.193\n0.487\n0.352\n\n\nObservations\n\n9\n9\n9\n\n\n\n\n\n\n\nSince the output of to_df is a pd.DataFrame, it is easy to add more information at the bottom of the table without having to re-run collect_stats.\n\ndf = estout.to_df(allmodels)\ndf.loc['Fixed effects',:] = ['No','No','Entity']\ndf\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\ncons\nparams\n0.51***\n0.70***\n0.73***\n\n\n\ntstats\n(3.91)\n(21.48)\n(167.36)\n\n\nx\nparams\n0.35\n0.57**\n0.64*\n\n\n\ntstats\n(1.29)\n(2.85)\n(2.26)\n\n\nz\nparams\n\n-0.64**\n-0.77**\n\n\n\ntstats\n\n(-3.55)\n(-2.91)\n\n\nr2\n\n0.193\n0.487\n0.352\n\n\nnobs\n\n9\n9\n9\n\n\nFixed effects\n\nNo\nNo\nEntity\n\n\n\n\n\n\n\n\n\nExporting to LaTex\nWith the estout.to_tex function, we can combine one or more DataFrames into a single LaTex table (each DataFrame will be a separate panel in the LaTex table).\nIn the example below, we just return the tex code as a string, but the function also takes an outfile parameter that allows us to store the output in a .tex file. Either the file path or the string can be used in the estout.to_pdf function to create a PDF out of this tex code.\n\ntbl = estout.to_tex([df,df], panel_title=['Panel A: Some title', 'Panel B: Some title'], \n               col_groups=[{'Group1':[1,2]}]*2,\n               col_names=[['Model 1', 'Model 2', 'Model 3']]*2,\n               hlines=[[0,1,4,13], [1,4,13]] )\nprint(tbl)\n\n\\newpage \n \\clearpage \n \\begin{table}[!h] \\footnotesize \n\\addtocounter{table}{0} \n\\caption{\\textbf{Table title}} \n\\par {Table description} \n\n \\vspace{2mm} \n\n \\begin{tabular*}{\\textwidth}{@{\\extracolsep{\\fill}}l*{3}{c}} \n \\hline \\noalign{\\smallskip} \n\\multicolumn{4}{@{} l}{Panel A: Some title} \\\\ \n \\hline \\noalign{\\smallskip} \n& \\multicolumn{2}{c}{Group1}  \\\\ \n\\cline{2-3}  \n & Model 1 & Model 2 & Model 3 \\\\ \n \\hline \\noalign{\\smallskip} \ncons & 0.51*** & 0.70*** & 0.73*** \\\\ \n & (3.91) & (21.48) & (167.36) \\\\ \nx & 0.35 & 0.57** & 0.64* \\\\ \n & (1.29) & (2.85) & (2.26) \\\\ \nz &  & -0.64** & -0.77** \\\\ \n &  & (-3.55) & (-2.91) \\\\ \nr2 & 0.193 & 0.487 & 0.352 \\\\ \nnobs & 9 & 9 & 9 \\\\ \nFixed effects & No & No & Entity \\\\ \n \\hline \\noalign{\\smallskip} \n\\end{tabular*}\n \\smallskip \n\\begin{tabular*}{\\textwidth}{@{\\extracolsep{\\fill}}l*{3}{c}} \n\\multicolumn{4}{@{} l}{Panel B: Some title} \\\\ \n \\hline \\noalign{\\smallskip} \n& \\multicolumn{2}{c}{Group1}  \\\\ \n\\cline{2-3}  \n & Model 1 & Model 2 & Model 3 \\\\ \n \\hline \\noalign{\\smallskip} \ncons & 0.51*** & 0.70*** & 0.73*** \\\\ \n & (3.91) & (21.48) & (167.36) \\\\ \nx & 0.35 & 0.57** & 0.64* \\\\ \n & (1.29) & (2.85) & (2.26) \\\\ \nz &  & -0.64** & -0.77** \\\\ \n &  & (-3.55) & (-2.91) \\\\ \nr2 & 0.193 & 0.487 & 0.352 \\\\ \nnobs & 9 & 9 & 9 \\\\ \nFixed effects & No & No & Entity \\\\ \n \\hline \\noalign{\\smallskip} \n\\end{tabular*} \n\\label{} \n \\end{table} \n\n\n\n\n\nExporting to PDF\nWith the estout.to_pdf function, we can combine the LaTex code for multiple tables (like the ones produced by estout.to_tex) into a single .tex document.\nBy default, the resulting .tex file is run through TexLive’s pdflatex utility to produce a PDF document with the tables (set make_pdf=False if you do not want the PDF to be automatically produced).\nYou can also set open_pdf to True if you want the resulting pdf to be opened after it is produced.\nFor the code below to work, you need to have TexLive installed (and change the path below to a valid path on your system).\n\nestout.to_pdf(outfile='../_outputs/paper.tex', \n              table_tex_code=[tbl, tbl],\n              make_pdf=True,\n              open_pdf=False)\n\nPDF creation successful!\n\n\nThis produced a PDF with two tables (given by the tbl tex string), each with two panels (given by the df DataFrame above).\nNote that the table_tex_code parameter also accepts paths to tex files. Those tex files must have the complete table environment for that table (i.e. from\n).",
    "crumbs": [
      "estout"
    ]
  }
]
# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% ../nbs/00_core.ipynb 4
from __future__ import annotations
from pathlib import Path 
from typing import List, Dict, Literal
import importlib

import numpy as np
import pandas as pd
import statsmodels.api as sm
from linearmodels import PanelOLS

from .utils import *

# %% auto 0
__all__ = ['collect_stats', 'to_df', 'to_tex']

# %% ../nbs/00_core.ipynb 7
def collect_stats(res, # Results object to extract stats from
                  get_default_stats = True, # If True, returns all stats implemented by the f'{package}_results' module
                  add_stats: dict=None, # Keys are stats to extract in addition to the default ones; values are attributes of 'res'
                  add_literals: dict=None, # Additional info to be added to output dict; values must be scalars
                  ) -> dict:
    """Collects stats from 'res' object. stats in 'add_stats' can override default stats()"""

    out = {'package': res.__module__.split('.')[0]}
    results_module = importlib.import_module(f"estout.{out['package']}_results")

    if get_default_stats:
        for stat in results_module.__all__:
            out[stat] = rgetattr(results_module, stat)(res)

    if add_stats is not None:
        for stat, attr in add_stats.items():
            out[stat] = rgetattr(res, attr)

    if add_literals is not None:
        out.update(add_literals)
        
    return out

# %% ../nbs/00_core.ipynb 13
def to_df(res_list: List[dict], # List of outputs from `collect_stats()`
          which_xvars: list=None, # If None, report all xvars
          stats_body: list=['params', 'tstats'], # Each element of 'res_list' needs to have these stats as keys; values must be pd.Series
          stats_bottom: list=['r2', 'nobs'], # Each element of 'res_list' needs to have these stats as keys; values must be scalars
          labels: dict=None,
          add_formats: dict=None  
          ) -> pd.DataFrame: 
    """Combines results from multiple `collect_stats()` outputs into a single pd.DataFrame"""  
    
    formats = default_formats()
    if add_formats is not None: formats.update(add_formats)
    
    columns = []
    for i,res in enumerate(res_list):
        newcol = pd.concat([res[x] for x in stats_body], axis=1, ignore_index=True).set_axis(stats_body, axis=1)
        for x in stats_body:
            newcol[x] = newcol[x].map(formats[x].format)
            if x == 'params':
                newcol[x] += get_stars(res['pvalues'])
            else:
                newcol[x] = '(' + newcol[x] + ')'
        newcol = newcol.stack(level=0) #set_index('coeff_names')
        columns.append(newcol)

    out = pd.concat(columns, axis = 1)
    if which_xvars is not None: out = out.loc[which_xvars].copy()
    
    for i,res in enumerate(res_list):
        for x in stats_bottom:
            out.loc[x,i] = formats[x].format(res[x]) if x in formats else res[x]

    if labels is not None:
        for var in set(out.droplevel(1).index):
            if var in labels: out = out.rename(index={var:labels[var]}, level=0) 

    #Clean up row names 
    out = out.reset_index()
    out.loc[~out['level_1'].isin(['params','']), 'level_0'] = ''
    out = out.set_index(['level_0','level_1'])
    out.index.names = (None,None)

    return out.astype('string').fillna('')

# %% ../nbs/00_core.ipynb 19
def to_tex(dfs: pd.DataFrame|List[pd.DataFrame], # (List of) outputs from estout.to_df()
            outfile: Path|str=None, # Where to save resulting tex output
            title: str='Table title', # Table title
            notes: str='Table description', # Some call this the table caption
            notes_on_top: bool=True, # Set to False if you want table description (caption) to be at the bottom
            label: str='', # Table label (for referencing within LaTex document)
            table_type: Literal['table','sidewaystable']='table',
            font_size: str='\scriptsize', # Gets applied to the table contents as well as its caption
            addtocounter: int=0, # Set to -1 for tables that are just a continuation of a table on a new page
            
            panel_titles: List[str] = None, # If 'dfs' is list, this param must have the same size as 'dfs' 
            ptitles_over_columns: bool=True,
            panel_alignment: str='c',
            space_bw_panels: str='\\rule{0pt}{3ex}',
            hlines_under_ptitles: bool=True,
            tex_tabular_env: str='tabularx',

            column_group_names: Dict[str, List[int]]=None, # see df_to_tex(); if 'dfs' is list, this param must be a list of dicts
            column_names: List[str]|bool=True, # see df_to_tex(); if 'dfs' is list, this param must be a list of lists
            hlines: List[int]=[] # see df_to_tex(); if 'dfs' is list, this param must be a list of lists
            ):

    if isinstance(dfs, pd.DataFrame): 
        panels = {'': df_to_tex(dfs, column_group_names, column_names, hlines)} 
        nr_columns = [len(dfs.columns)]
    if isinstance(dfs, list):
         panels = {panel_titles[i]: df_to_tex(dfs[i], column_group_names[i], column_names[i], hlines[i])
                   for i in range(len(dfs))} 
         nr_columns = [len(dfs[i].columns) for i in range(len(dfs))]
    
    body = combine_panels(panels, nr_columns, ptitles_over_columns, panel_alignment, space_bw_panels, hlines_under_ptitles, tex_tabular_env)

    pre = "\\newpage \n \\clearpage \n "
    pre += f"\\begin{{{table_type}}}[!h] {font_size} \n"
    pre += f"\\addtocounter{{table}}{{{addtocounter}}} \n"
    pre += f"\\caption{{\\textbf{{{title}}}}} \n"

    post = f"\\label{{{label}}} \n \\end{{{table_type}}} \n"

    notes_tex = ''
    if addtocounter==0: notes_tex = f"\\par {{{notes}}}"

    if notes_on_top:
        mid = notes_tex + f" \n\n \\vspace{{{'1mm'}}} \n\n {body} \n"
    else:
        mid = f"{body} \n\n \\vspace{{{'1mm'}}} \n\n " + notes_tex + ' \n'

    content = pre + mid + post

    if outfile:
        with open(outfile, "+w") as f:
            f.write(content) 
    return content
